# -*- coding: utf-8 -*-
"""
Created on Wed Jul  6 12:44:53 2022

@author: kayla
"""

###############################################################################
# Original randlin function:

# Input Arguments:
# ebsd      ... the ebsd data saved from MATLAB that contains all of the structure's MTEX data
# n         ... number of random lines to be generated (integer)
# grains    ... MTEX grain2d object, saved from MATLAB
# stepsize  ... ebsd stepsize, saved from MATLAB

# Returns
# P_L                               ... proper intercept count, taking into account the ends of the lines and triple points (scalar)
# total_line_length                 ... sum of the length of all the random lines (scalar)
# intercept_lengths                 ... lengths between intersections (n x 1 array)
# gb_intersection_coordinates       ... column 1: x coordinate start of line
#                                       column 2: x coordinate end of line
#                                       column 3: y coordinate start of line
#                                       column 4: y coordinate end of line
#                                       column 5: number of intersections recorded (does not take into account whether intersection is at triple pt)
#                                       column 6: length of line
#                                       (n x 6 array)
# triplept_intersection_coordinates ... column 1: x coordinate of intersection coincident with triple point
#                                       column 2: y coordinate of intersection coincident with triple point

###############################################################################
# Updated randlin inputs:

# Input Arguments:
# ebsd      ... the ebsd data that contains all of the structure's MTEX data, saved from MATLAB
# n         ... number of random lines to be generated (integer)
# grains    ... MTEX grain2d object, saved from MATLAB
# stepsize  ... ebsd stepsize, saved from MATLAB
# ntpoints  ... the number of triple points as generated by MTEX, saved from MATLAB (see line 54 below)
# tpoint    ... the coordinates of the triple points, saved from MATLAB (see line 52 below)
# [xi, yi]  ... the coordinates of the intersections of the grain boundaries, saved from MATLAB (see line 58 below)


###############################################################################
# should utilize matlab to do the following:
## have mtex get the coordinates of triple points
# tP = grains.triplePoints
# xii = tP.x
# yii = tP.y
# tpoint = [xii, yii] *** TO BE IMPORTED INTO PYTHON ***
# ntpoints = size(tpoint)
# ntpoints = ntpoints(1) *** TO BE IMPORTED INTO PYTHON ***

# should utilize matlab to do the following:
## have mtex get the intersections *** (lines 132-133 of matlab code)***
# [xi, yi] = grains.boundary.intersect(xy1,xy2) *** TO BE IMPORTED INTO PYTHON ***

# ntpoints, tpoint, xi, and yi appear to have been in varargin in MTEX
def randlin(ebsd, n, grains, stepsize, ntpoints, tpoint, xi, yi):
    import numpy as np
    import math

    total_line_length = 0

    # begin the loop over the desired number of random lines
    for k in range(0, n):

        # Get scan dimensions
        xdim_max = math.ceil(max(grains.x))
        ydim_max = math.ceil(max(grains.y))
        xdim_min = math.floor(min(grains.x))
        ydim_min = math.floor(min(grains.y))

        # Boundaries of the structure
        xdim = [xdim_min, xdim_max]  # x-coordinates of the boundary
        ydim = [ydim_min, ydim_max]  # y-coordinates of the boundary

        y = (ydim[1] - ydim[0]) * np.random.randint(size=(2, 1)) + ydim[0]
        x = (xdim[1] - xdim[0]) * np.random.randint(size=(2, 1)) + xdim[0]
        x2 = x[1]
        x1 = x[0]
        y2 = y[1]
        y1 = y[0]

        # get slope and intercept of line
        m = (y2 - y1) / (x2 - x1)
        b = y2 - m * x2  # intercept from y = mx + b

        # get intersections with bounding box
        yya = m * xdim[0] + b  # value of y at left edge on line
        if yya > ydim[1]:  # then the x1 coordinate is along the top edge
            bbx1 = (ydim[1] - b) / m
        elif yya < ydim[0]:  # then the x1 coordinate is along the bottom edge
            bbx1 = (ydim[0] - b) / m
        else:  # then the x-coordinate is the left edge
            bbx1 = xdim[0]

        yyb = m * xdim[1] + b  # value of y at right edge on line
        if yyb > ydim[1]:  # then the x2 coordinate is along top edge
            bbx2 = (ydim[1] - b) / m
        elif yyb < ydim[0]:  # then x2 coordinate is along bottom edge
            bbx2 = (ydim[0] - b) / m
        else:  # then x coordinate is the right edge
            bbx2 = xdim[1]

        xxa = (ydim[0] - b) / m  # value of x at y1 on line
        if xxa > xdim[1]:  # then the y1 coordinate is along right edge
            bby1 = xdim[1] * m + b
        elif xxa < xdim[0]:  # then the y2 coordinate is along left edge
            bby1 = xdim[0] * m + b
        else:  # then y coordinate is the bottom edge
            bby1 = ydim[0]

        xxb = (ydim[1] - b) / m  # value of x on line at upper edge of bounding box
        if xxb > xdim[1]:  # then the y2 coordinate is along right edge
            bby2 = xdim[1] * m + b
        elif xxb < xdim[0]:  # then the y2 coordinate is along left edge
            bby2 = xdim[0] * m + b
        else:  # it must be the top edge
            bby2 = ydim[1]

        # collect our line starting and ending points and correct for slope
        offset = 1.0
        if m > 0:
            # xy1 = [bbx1, bby1] + offset * stepsize
            # xy2 = [bbx2, bby2] - offset * stepsize
            bb_array_1 = [bbx1, bby1]
            bb_array_2 = [bbx2, bby2]
            xy1 = [bb_array_1[0] + offset * stepsize, bb_array_1[1] + offset * stepsize]
            xy2 = [bb_array_2[0] + offset * stepsize, bb_array_2[1] + offset * stepsize]
        else:
            xy1 = [bbx1 + offset, bby2 - offset * stepsize]
            xy2 = [bbx2 - offset, bby1 + offset * stepsize]

        # call on the saved .mat file to populate the x-y coordinates of the intersections
        # [xi,yi]

        # find the number of boundary intersection points
        # int_count = sum(~isnan(xi))
        int_count = sum(~np.isnan(xi))  # xi not recognized because of **mtex imported data**

        # get the x-y coordinates of the interceptions
        # xx1 = xi(~isnan(xi))
        # yy1 = yi(~isnan(yi))
        # xi and yi not recognized because of **mtex imported data**
        k1 = [i for i in range(len(xi)) if ~np.isnan(xi[i])]
        k2 = [i for i in range(len(yi)) if ~np.isnan(yi[i])]
        xx1 = xi[k1]  # xi not recognized because of **mtex imported data**
        yy1 = yi[k2]  # yi not recognized because of **mtex imported data**
        line_no = k * np.ones((1, len(xx1)))
        gb_intersection_coordinates = np.hstack((xx1, yy1, line_no))  # --- QUESTION: Would this be hstack or vstack?

        # total length of the line
        tot = np.sqrt((xy2[1] - xy1[1]) ** 2 + (xy2[0] - xy1[0]) ** 2)  # distance formula
        total_line_length = total_line_length + tot

        # collate info from individual lines
        line_intersection_results = np.hstack((xy1[0], xy1[1], xy2[0], xy2[1], int_count, tot))

    ###########################################################################

    # calculate the distance between intersection points and triple points
    tp_thresh = 1.0
    for m in range(0, ntpoints):

        gb_coord_1 = gb_intersection_coordinates[0:, 0]
        gb_coord_2 = gb_intersection_coordinates[0:, 1]

        for m2 in range(0, len(gb_coord_1)):
            # distance in microns:
            # tpoint not recognized because of **mtex imported data**
            dist = np.sqrt((tpoint[m, 0] - gb_coord_1[m2]) ** 2 +
                           (tpoint[m, 1] - gb_coord_2[m2]) ** 2 *
                           tp_thresh * stepsize)

            # find the distance under threshold and use that as an index into xyints:
            gb_index = [i for i in range(len(gb_coord_1)) if dist[i] < stepsize]
            coord = gb_intersection_coordinates[gb_index, :]
            xcoord = coord[:, 0]
            ycoord = coord[:, 1]
            triplept_intersection_coordinates = np.hstack((xcoord, ycoord))

    # get the count of intersections through the triple points
    # (from xcoord and ycoord)
    tpcount = len(xcoord)

    # count the intersections: the ends count as half, hence the -1;
    # add 0.5 counts for each time the line goes through a triple point
    P_L = sum(line_intersection_results[:, 4]) + 0.5 * tpcount - 1

    # calculate the intercept lengths
    len_gb = len(gb_intersection_coordinates)
    intercept_lengths = np.sqrt((gb_intersection_coordinates[0:len_gb - 1, 0] -
                                 gb_intersection_coordinates[1:, 0]) ** 2 +
                                (gb_intersection_coordinates[0:len_gb - 1, 1] -
                                 gb_intersection_coordinates[1:, 1]) ** 2)

    return intercept_lengths
    return triplept_intersection_coordinates
    return P_L
